\section{Methodology}

The prospective solution was ultimately named \emph{Packet Courier} for reasons that the ensuing design documentation
aims to make clear. In summary, Packet Courier listens for packets being sent by nodes on its virtual network,
processing and rerouting them according to their listed destination and the associated conditions; just as a mail
courier would do analogously for letters and parcels. The metaphor also aligns itself well with the overall
motivations of the project, whereby postal services are largely seen as reliable infrastructure that operate silently
in the background, enabling people to send goods across seemingly vast distances without needing to worry about how
this is achieved. Indeed, these are the ideals that Packet Courier strives to embody, especially in light of
objectives 4) and 5).

Packet Courier has been designed and developed by leveraging philosophies from the \emph{lean development} school of
thought\cite{william_feld_lean_book, steve_blank_lean_blog}. This involved making Packet Courier a functional and
useful piece of software from the very first iteration, and continuing to ensure that this remained so with each new
feature. As a consequence, every supervisory meeting, informal peer review or user ``playtest'' would be a
meaningfully different experience, with something novel to demonstrate on each occasion. In this way, any feedback
could be readily taken on-board and implemented quickly. By contrast, if Packet Courier had been meticulously
designed from the bottom-up or the top-down, even the smallest changes in direction could risk rendering much of the
planning totally obsolete.

The simplest way to guarantee that Packet Courier provided users with tangible value from day one was to integrate an
application-programmer interface into the base simulation engine. That way, developers could always take advantage of
what Packet Courier had to offer, even if it was primitive. This ended up paying dividends down-the-line, as it was this
combination of design philosophy and system architecture that facilitated the development of Packet Courier's
emulation mode, which leveraged the base simulation APIs to further empower Packet Courier to manipulate authentic
UDP packets in real-time.


\section{High-Level Architecture}

\subsection{Simulation Semantics}

Many of Packet Courier's core abstractions are inspired by the Elixir programming language\cite{elixir}. One of
Elixir's major selling points is how elegantly it removes unnecessary detail when interfacing with the programmer.
Rather than hemming developers into considering bits being sent over a wire, or packets being sent over a network,
Elixir talks in terms of \emph{processes} exchanging \emph{messages} with one another, which could consist of any
high-level object such as text, numbers, tuples, or even higher-order structures like lists and structs.
Furthermore, Elixir uses neat allegories to help developers build up a more intuitive picture of what their code
does, i.e.: collecting messages from a \emph{mailbox} or using an arbitrary \emph{process-id} rather than an
ip-address. Not only does this improve readability, but it also insulates the logic of the distributed algorithms
from the lower-level details of the machine or the network. Is \texttt{ipv4} or \texttt{ipv6} being used? An Elixir
developer wouldn't need to know or care.

As such, Packet Courier channels Elixir's spirit of using intuitive, high-level concepts to help users quickly build
an understanding for a given simulation. As one might expect, the \emph{Node} is a cornerstone abstraction within the
Packet Courier framework. A node represents a particular location within a wider network topology and enjoys a unique
\emph{Node Address}. Each node will have at least one \emph{Worker}, where each worker will in turn carry out some
work in the form of a coroutine. Workers also have access to a \emph{Postal Service} which enables them to interact
with the wider network by sending a \emph{Packet} to a destination \emph{WorkerAddress}. The postal service will then
package the packet and destination worker address into a single piece of \emph{Mail} and send it along the
\emph{NodeConnection} associated with the source and destination worker addresses (provided it exists). Notice that
the mail is sent along a node connection, as opposed to a \emph{worker} connection, because mail is principally
exchanged between nodes rather than workers. In this way, when a piece of mail arrives at its destination node, the
node extracts and routes the packet to its respective worker address; idiomatically speaking, the node
\emph{Delivers} the packet to the worker's \emph{Mailbox}. The worker then has the option to poll packets from its
mailbox. It is important to note that mailboxes store packets, not \emph{mail}. The rationale behind this is that one
needn't accompany their letter or parcel with a return address in order to send it; this is a choice that can be made
at the sender's discretion. Workers are also granted privacy, meaning that they can only see the contents of their own
mailbox.


\section{Top-Down Specification}

TODO

\subsection{Application-Programmer Interface}

TODO

\subsection{Standalone Emulator}

TODO
