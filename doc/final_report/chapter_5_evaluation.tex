\section{Unit Testing}\label{section:unit_testing}

Whilst unit testing is often seen to be a menial aspect of ensuring robustness in software engineering projects,
unit tests in Packet Courier are used to verify the correctness of the statistical distribution implementations,
which is somewhat non-trivial. Each distribution is subjected to two different tests:
\begin{itemize}
    \item $n$ samples are taken of the distribution variable $X$ and their mean $\bar{X}$ must lie within an $\alpha
    = 0.01$ confidence interval. $n$ is set to $10,000$ for this test. This is exactly why the \texttt{mean} and
    \texttt{variance} methods in \texttt{Distribution<T>} are necessary, as per the end of
    Section~\ref{subsection:statistical_distribution_api}. The benefit of this test is that it assures statistical
    distribution API users that the distributions they are using are unbiased and boast the correct expected value.
    \item $n$ samples are taken of the distribution variable $X$ and separated into $m$ contiguous bins, $B_1, \dots ,
    B_m$ delimited by boundary values $b_1, \dots , b_m, b_{m+1}$. The contents of each bin $B_i$ must reflect the
    following property: $\frac{|B_i|}{m} - \delta \leq F_X(b_{i+1}) - F_X(b_i) \leq \frac{|B_i|}{m} + \delta$ for
    $\delta = 0.01$. $n$ is set to $50,000$ for this test. The benefit of this test is that is assures statistical
    distribution API users that the distributions have roughly the correct shape. In this way, one could think about
    this test like the proof of calculus' Trapezoidal Rule\cite{trapezoidal_rule}, whereby the trapezoids under the
    curve are analogous to the bins under the probability density function.
\end{itemize}

This is technically achieved by having a base abstract \texttt{DistributionTest<T>} class that implements tests
generically using the \texttt{Distribution<T>} interface. The key abstract method is
\texttt{getSomeDistributionsWithCdfTables} which generates a selection of distributions and tabulated cumulative
distribution functions. In turn, a suite of test classes inherit from \texttt{DistributionTest<T>} and supply it with
some distributions and CDF-tables to conduct tests on.


\section{System Testing}\label{section:system_testing}

Packet Courier takes advantage of system testing to ensure that the aggregate properties of packets sent over an
emulated network accurately reflect those specified in the \texttt{.courierconfig} file. A selection of
configurations have been specified in \texttt{src/test/resources/thorpe/luke/network/simulation/analysis} to cover
the six fundamental offerings: corruption, drop, duplication, latency, limit and throttle. These can be run from the
root of the directory using \texttt{run\_basic\_analysis\_suite.sh}. Each configuration consists of a star topology
with either 5, 25, 50, 75 or 100 clients which send 50 packets per second to a server. Clients log the contents of
their packet and when they sent them. The server logs the contents of the packet it has received and when it received
them. The logs are then dumped to a file and analysed in post.


\section{User Feedback}\label{section:user_feedback}

TODO


\section{Analysis of Objectives}\label{section:analysis_of_objectives}

\subsection{Network Topology Design Interface}\label{subsection:network_topology_design_interface}

\textbf{Objective 1: }\emph{An interface to design an arbitrary network topology.}

\subsection{Network Conditions Configuration Suite}\label{subsection:network_conditions_configuration_suite }

\textbf{Objective 2: }\emph{A configuration suite to define how packets are manipulated during message-passing.}

\subsection{Simulation of a Distributed Algorithm}\label{subsection:simulation_of_a_distributed_algorithm}

\textbf{Objective 3: }\emph{A mechanism to run a distributed algorithm across a virtual network topology which
reflects the
properties described by the user as per objectives 1) and 2).}

\subsection{Platform Agnosticism}\label{subsection:platform_agnosticism}

\textbf{Objective 4.a: }\emph{Basic usage of the tool should not depend on the operating system or hardware being used
.} \\ \\
\textbf{Objective 4.b: }\emph{Users should not be pigeonholed into working with a particular programming language in
order to
simulate their solution.}

\subsection{Plug-and-playability}\label{subsection:plug_and_playability}

\textbf{Objective 5.a: }\emph{Users should need minimal domain-specific knowledge in order to use the full set of
features on offer.} \\ \\
\textbf{Objective 5.b: }\emph{The prospective tool should be able to mimic a real network in a way that minimises
bespoke set-up, i.e.: if a user normally tests their distributed algorithm using real computers connected over a
physical network, then transitioning to using the prospective tool should be more or less seamless.}
